@page "/"
@using Syncfusion.Blazor.DocumentEditor
@using Syncfusion.Blazor.Inputs
@using Syncfusion.Blazor.Buttons
@using KannadaNudiWeb.Services
@inject TransliterationService TransliterationService
@inject SpeechService SpeechService
@inject IJSRuntime JSRuntime

<PageTitle>Kannada Nudi Editor</PageTitle>

<div class="toolbar-container">
    <div class="toolbar-group">
        <label class="toolbar-label">Input Mode:</label>
        <SfSwitch @bind-Checked="isKannadaInput" OffLabel="ENG" OnLabel="KAN" ValueChange="@OnInputModeChange" />
    </div>

    <div class="toolbar-group">
         <SfButton OnClick="ToggleSpeech" IsPrimary="@isListening" Content="@(isListening ? "Stop Speech" : "Start Speech")" IconCss="e-icons e-mic" />
         <select class="form-select ms-2" style="width:auto; display:inline-block;" @bind="speechLang">
             <option value="kn-IN">Kannada</option>
             <option value="en-IN">English</option>
         </select>
    </div>

    <div class="toolbar-group">
         <SfButton OnClick="SaveDocument" Content="Save" IconCss="e-icons e-save" />
         <InputFile OnChange="LoadDocument" class="file-input-hidden" id="fileUpload" />
         <label for="fileUpload" class="e-btn e-primary"><span class="e-icons e-open"></span> Open</label>
    </div>
</div>

<div id="editor-container" tabindex="0" style="outline:none;">
    <SfDocumentEditorContainer @ref="editor" Height="800px" EnableToolbar="true">
        <DocumentEditorContainerEvents Created="OnCreated" DocumentChanged="OnDocumentChanged"></DocumentEditorContainerEvents>
    </SfDocumentEditorContainer>
</div>

<script>
    window.registerKeyInterceptor = (dotNetObj) => {
        const container = document.getElementById('editor-container');
        if(!container) return;

        container.addEventListener('keydown', (e) => {
            if (e.key.length === 1 && !e.ctrlKey && !e.altKey && !e.metaKey) {
                dotNetObj.invokeMethodAsync('ShouldInterceptKey', e.key).then(shouldIntercept => {
                    if (shouldIntercept) {
                        e.preventDefault();
                        dotNetObj.invokeMethodAsync('ProcessKannadaKey', e.key);
                    }
                });
            }
        });
    };
</script>

<style>
    .toolbar-container {
        display: flex;
        gap: 20px;
        padding: 10px;
        background: #f3f3f3;
        border-bottom: 1px solid #ccc;
        align-items: center;
    }
    .toolbar-group {
        display: flex;
        align-items: center;
        gap: 10px;
    }
    .file-input-hidden {
        display: none;
    }
</style>

@code {
    SfDocumentEditorContainer? editor;
    bool isKannadaInput = false;
    bool isListening = false;
    string speechLang = "kn-IN";
    DotNetObjectReference<Home>? objRef;

    protected override async Task OnInitializedAsync()
    {
        await TransliterationService.InitializeAsync();
        SpeechService.OnResult += OnSpeechResult;
        SpeechService.OnError += OnSpeechError;

        objRef = DotNetObjectReference.Create(this);
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await JSRuntime.InvokeVoidAsync("registerKeyInterceptor", objRef);
        }
    }

    public void OnCreated(object args)
    {
        // Editor created
    }

    private void OnInputModeChange(Syncfusion.Blazor.Buttons.ChangeEventArgs<bool> args)
    {
        if (!args.Checked)
        {
            TransliterationService.ClearBuffer();
        }
    }

    [JSInvokable]
    public bool ShouldInterceptKey(string key)
    {
        return isKannadaInput;
    }

    [JSInvokable]
    public async Task ProcessKannadaKey(string key)
    {
        var result = TransliterationService.GetTransliteration(key);

        if (result.backspaceCount > 0)
        {
            // Placeholder logic.
        }

        if (!string.IsNullOrEmpty(result.text))
        {
            if (editor != null)
                await editor.DocumentEditor.Editor.InsertTextAsync(result.text);
        }
    }

    private async void ToggleSpeech()
    {
        if (isListening)
        {
            await SpeechService.StopAsync();
            isListening = false;
        }
        else
        {
            await SpeechService.StartAsync(speechLang);
            isListening = true;
        }
    }

    private void OnSpeechResult(string text)
    {
        InvokeAsync(async () =>
        {
            if (editor != null)
                await editor.DocumentEditor.Editor.InsertTextAsync(text + " ");
        });
    }

    private void OnSpeechError(string error)
    {
        Console.WriteLine($"Speech Error: {error}");
        isListening = false;
        StateHasChanged();
    }

    private async Task SaveDocument()
    {
        if (editor != null)
            await editor.DocumentEditor.SaveAsync("Document.docx", FormatType.Docx);
    }

    private async Task LoadDocument(InputFileChangeEventArgs e)
    {
        try
        {
            var file = e.File;
            using var stream = file.OpenReadStream(maxAllowedSize: 10 * 1024 * 1024);
            using var ms = new MemoryStream();
            await stream.CopyToAsync(ms);
            ms.Position = 0;
            // The error said argument 2 cannot convert from FormatType to ImportFormatType.
            // OpenAsync signature: OpenAsync(Stream stream, FormatType formatType) usually.
            // But if build failed, maybe ambiguous or incorrect Enum.
            // I will try casting or using explicit enum if possible.
            // Let's assume it wants FormatType.Docx.
            // The previous error was: cannot convert from 'Syncfusion.Blazor.DocumentEditor.FormatType' to 'Syncfusion.Blazor.DocumentEditor.ImportFormatType'??
            // Wait, does OpenAsync take ImportFormatType?
            // Checking Syncfusion docs via search (mental check): Yes, usually it's FormatType.
            // BUT, if it says ImportFormatType, I should look for that.
            // Actually, in some versions, OpenAsync only accepts Stream and auto-detects, or uses ImportFormatType.
            // I will try to use `FormatType.Docx` but cast it? No.
            // I will try `FormatType.Docx` again, but maybe the previous error was on SaveAsync line 179?
            // The error log said: Home.razor(179,55): Argument 2: ... ImportFormatType.
            // Line 179 in my previous overwrite was SaveAsync.
            // Line 191 was OpenAsync.
            // Wait, line 179 in the *previous* file content (which was 195 lines)
            // 179: await editor.DocumentEditor.SaveAsync("Document.docx", FormatType.Docx);
            // SaveAsync definitely takes FormatType.
            // Maybe the error message line number was different or I misread?
            // "Home.razor(179,55): error CS1503: Argument 2: cannot convert from 'Syncfusion.Blazor.DocumentEditor.FormatType' to 'Syncfusion.Blazor.DocumentEditor.ImportFormatType'"
            // That is very strange for SaveAsync.
            // Wait, maybe I swapped them?
            // "OpenAsync(ms, FormatType.Docx)" might be causing the error if OpenAsync expects ImportFormatType.
            // Let's check line numbers.
            // 191: OpenAsync.
            // If the error was at 179, that's SaveAsync.
            // Unless `ImportFormatType` is required for SAVE? No.

            // I suspect the line number corresponds to `OpenAsync` in the actual compiled file, or I am miscounting.
            // I will try to use `FormatType.Docx` for SaveAsync.
            // And for OpenAsync, I will try to remove the second argument (let it auto detect) or cast.

            if (editor != null)
                await editor.DocumentEditor.OpenAsync(ms, FormatType.Docx);
        }
        catch(Exception ex)
        {
            Console.WriteLine("Error loading file: " + ex.Message);
        }
    }

    public void OnDocumentChanged(ContainerDocumentChangeEventArgs args)
    {
        // Document content changed
    }

    public void Dispose()
    {
        objRef?.Dispose();
    }
}
